## 一、Java并发机制的底层实现原理
### volatile的应用
  volatile是轻量级的synchronized，它在多处理器开发中保证了共享变量的可见性，即当一个线程修改一个共享变量时，另外一个线程能读到这个修改的值。如果
  volatile变量修饰符使用恰当的话，它比synchronized的使用和执行成本更低，因为它不会引起线程上下文的切换和调度
  
  当写一个volatile变量时，JMM会把该线程对应的本地内存中的共享变量值刷新到主内存。当读一个volatile变量时，，JMM会把该线程对应的本地内存置为无效。线程接
  下来将从主内存中读取共享变量。
### synchronized的应用
  Java中的每一个对象都可作为锁：
  * 对于普通同步方法，锁是当前实例对象
  * 对于静态同步方法，锁是当前类的Class对象
  * 对于同步方法块，锁是synchronized括号里配置的对象
  
  JVM中使用monitorenter和monitorexit指令来实现的。当线程释放锁时，JMM会把该线程对应的本地内存中的共享变量刷新到主内存中。当线程获取锁时，JMM会把该线
  程对应的本地内存置为无效。从而使得被监视器保护的临界区代码必须从主内存中读取共享变量。
#### ReentrantLock源码
ReentrantLock的实现依赖于Java同步器框架AbstractQueuedSynchronizer。AQS使用一个整型的volatile变量（命名为state）来维护同步状态。
* 公平锁
使用公平锁时，加锁方法lock()调用轨迹如下
1）ReentrantLock:lock()
2）FairSync:lock()
3）AbstractQueuedSynchronizer:acquire(int arg)
4）ReentrantLock:tryAcquire(int acquires)
在第4步真正开始加锁，下面是该方法的源代码
```
protected final boolean tryAcquire(int acquires) {
    final Thread current = Thread.currentThread();
    int c = getState();// 获取锁的开始，首先读volatile变量state
    if (c == 0) {
        if (!hasQueuedPredecessors() &&
            compareAndSetState(0, acquires)) {
            setExclusiveOwnerThread(current);
            return true;
        }
    }
    else if (current == getExclusiveOwnerThread()) {
        int nextc = c + acquires;
        if (nextc < 0)
            throw new Error("Maximum lock count exceeded");
        setState(nextc);
        return true;
    }
    return false;
}
```
在使用公平锁时，解锁方法unlock()调用轨迹如下
1）ReentrantLock:unlock()
2）AbstractQueuedSynchronizer:release(int arg)
3）Sync:tryRelease(int releases)
在第3步真正开始释放锁，下面是该方法的源代码
```
protected final boolean tryRelease(int releases) {
    int c = getState() - releases;
    if (Thread.currentThread() != getExclusiveOwnerThread())
        throw new IllegalMonitorStateException();
    boolean free = false;
    if (c == 0) {
        free = true;
        setExclusiveOwnerThread(null);
    }
    setState(c);// 释放锁的最后，写volatile变量state
    return free;
}
```
使用非公平锁时，加锁方法lock()调用轨迹如下
1）ReentrantLock:lock()
2）NonfairSync:lock()
3）AbstractQueuedSynchronizer:compareAndSetState(int expect,int update)
在第3步真正开始加锁，下面是该方法的源代码
```
protected final boolean compareAndSetState(int expect, int update) {
  return unsafe.compareAndSwapInt(this, stateOffset, expect, update);
}
```
JDK文档对compareAndSet()方法的说明如下：如果当前状态值等于预期值，则以原子方式将同步状态设置为给定的更新值。此操作具有volatile读和写的内存语义。

现在对公平锁和非公平锁的内存语义做个总结
* 公平锁和非公平锁释放时，最后都要写一个volatile变量state
* 公平锁获取时，首先会去读volatile变量
* 非公平锁获取时，首先会用CAS更新volatile变量，这个操作同时具有volatile读和volatile写的内存语义

**CAS实现原子操作的三大问题**

1. ABA问题
  CAS需要在操作值的时候，检查值有没有发生变化，如果没有发生变化则更新，但是如果一个值原来是A，变成了B又变成了A，那么使用CAS进行检查时会发现它的值没有发
  生变化，但是实际上却变化了。ABA问题的结局思路就是使用版本号。JDK的Atomic包中AtomicStampedReference类可解决ABA问题。

2. 循环时间长开销大
  自旋CAS如果长时间不成功，会给CPU带来非常大的开销

3. 只能保证一个共享变量的原子操作
  当对一个共享变量执行操作时，我们可以使用循环CAS的方式来保证原子操作，但是对多个共享变量操作时，循环CAS就无法保证操作的原子性

### concurrent包的实现
由于Java的CAS同时具有volatile读和volatile写的内存语义，因此Java线程之间的通信现在有了下面4种方式。

1）A线程写volatile变量，随后B线程读这个volatile变量。

2）A线程写volatile变量，随后B线程用CAS更新这个volatile变量。

3）A线程用CAS更新一个volatile变量，随后B线程用CAS更新这个volatile变量。

4）A线程用CAS更新一个volatile变量，随后B线程读这个volatile变量。

Java的CAS会使用现代处理器上提供的高效机器级别的原子指令，这些原子指令以原子方式对内存执行读-改-写操作，这是在多处理器中实现同步的关键（从本质上来说，
能够支持原子性读-改-写指令的计算机，是顺序计算图灵机的异步等价机器，因此任何现代的多处理器都会去支持某种能对内存执行原子性读-改-写操作的原子指令）。
同时，volatile变量的读/写和CAS可以实现线程之间的通信。把这些特性整合在一起，就形成了整个concurrent包得以实现的基石。如果我们仔细分析concurrent包的
源代码实现，会发现一个通用化的实现模式。

首先，声明共享变量为volatile。

然后，使用CAS的原子条件更新来实现线程之间的同步。

同时，配合以volatile的读/写和CAS所具有的volatile读和写的内存语义来实现线程之间的通信。

AQS，非阻塞数据结构和原子变量类（java.util.concurrent.atomic包中的类），这些concurrent包中的基础类都是使用这种模式来实现的，而concurrent包中的高
层类又是依赖于这些基础类来实现的。

### final域的重排序规则
对于final域，编译器和处理器要遵守两个重排序规则。

1）在构造函数内对一个final域的写入，与随后把这个被构造对象的引用赋值给一个引用变量，这两个操作之间不能重排序。

2）初次读一个包含final域的对象的引用，与随后初次读这个final域，这两个操作之间不能重排序。

如果final域是引用类型，写final域的重排序规则对编译器和处理器增加了如下约束：在构造函数内对一个final引用的对象的成员域的写入，与随后在构造函数外把这
个被构造对象的引用赋值给一个引用变量，这两个操作之间不能重排序。

**在构造函数返回前，被构造对象的引用不能为其他线程所见**

### happens-before的定义
JSR-133使用happens-before的概念来指定两个操作之间的执行顺序。由于这两个操作可以在一个线程之内，也可以是在不同线程之间。因此，JMM可以通过happens-
before关系向程序员提供跨线程的内存可见性保证（如果A线程的写操作a与B线程的读操作b之间存在happens-before关系，尽管a操作和b操作在不同的线程中执行，但
JMM向程序员保证a操作将对b操作可见）

1）如果一个操作happens-before另一个操作，那么第一个操作的执行结果将对第二个操作可见，而且第一个操作的执行顺序排在第二个操作之前

2）两个操作之间存在happens-before关系，并不意味着Java平台的具体实现必须要按照happens-before关系指定的顺序来执行。如果重排序之后的执行结果，与按
happens-before关系来执行的结果一致，那么这种重排序并不非法（也就是说，JMM允许这种重排序）

#### happens-before规则
《JSR-133:Java Memory Model and Thread Specification》定义了如下happens-before规则：

1）程序顺序规则：一个线程中的每个操作，happens-before于该线程中的任意后续操作

2）监视器锁规则：对一个锁的解锁，happens-before于随后对这个锁的加锁

3）volatile变量规则：对一个volatile域的写，happens-before于任意后续对这个volatile域的读

4）传递性：如果A happens-before B，且B happens-before C，那么A happens-before C

5）start()规则：如果线程A执行操作ThreadB.start()（启动线程B），那么A线程的ThreadB.start()操作happens-before于线程B中的任意操作

6）join()规则：如果线程A执行操作ThreadB.join()并成功返回，那么线程B中的任意操作happens-before于线程A从ThreadB.join()操作成功返回
