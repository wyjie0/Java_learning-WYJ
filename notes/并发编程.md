## 一、Java并发机制的底层实现原理
### volatile的应用
  volatile是轻量级的synchronized，它在多处理器开发中保证了共享变量的可见性，即当一个线程修改一个共享变量时，另外一个线程能读到这个修改的值。如果
  volatile变量修饰符使用恰当的话，它比synchronized的使用和执行成本更低，因为它不会引起线程上下文的切换和调度
  
  当写一个volatile变量时，JMM会把该线程对应的本地内存中的共享变量值刷新到主内存。当读一个volatile变量时，，JMM会把该线程对应的本地内存置为无效。线程接
  下来将从主内存中读取共享变量。
### synchronized的应用
  Java中的每一个对象都可作为锁：
  * 对于普通同步方法，锁是当前实例对象
  * 对于静态同步方法，锁是当前类的Class对象
  * 对于同步方法块，锁是synchronized括号里配置的对象
  
  JVM中使用monitorenter和monitorexit指令来实现的。当线程释放锁时，JMM会把该线程对应的本地内存中的共享变量刷新到主内存中。当线程获取锁时，JMM会把该线
  程对应的本地内存置为无效。从而使得被监视器保护的临界区代码必须从主内存中读取共享变量。
#### ReentrantLock源码
ReentrantLock的实现依赖于Java同步器框架AbstractQueuedSynchronizer。AQS使用一个整型的volatile变量（命名为state）来维护同步状态。
* 公平锁
使用公平锁时，加锁方法lock()调用轨迹如下
1）ReentrantLock:lock()
2）FairSync:lock()
3）AbstractQueuedSynchronizer:acquire(int arg)
4）ReentrantLock:tryAcquire(int acquires)
在第4步真正开始加锁，下面是该方法的源代码
```
protected final boolean tryAcquire(int acquires) {
    final Thread current = Thread.currentThread();
    int c = getState();// 获取锁的开始，首先读volatile变量state
    if (c == 0) {
        if (!hasQueuedPredecessors() &&
            compareAndSetState(0, acquires)) {
            setExclusiveOwnerThread(current);
            return true;
        }
    }
    else if (current == getExclusiveOwnerThread()) {
        int nextc = c + acquires;
        if (nextc < 0)
            throw new Error("Maximum lock count exceeded");
        setState(nextc);
        return true;
    }
    return false;
}
```
在使用公平锁时，解锁方法unlock()调用轨迹如下
1）ReentrantLock:unlock()
2）AbstractQueuedSynchronizer:release(int arg)
3）Sync:tryRelease(int releases)
在第3步真正开始释放锁，下面是该方法的源代码
```
protected final boolean tryRelease(int releases) {
    int c = getState() - releases;
    if (Thread.currentThread() != getExclusiveOwnerThread())
        throw new IllegalMonitorStateException();
    boolean free = false;
    if (c == 0) {
        free = true;
        setExclusiveOwnerThread(null);
    }
    setState(c);// 释放锁的最后，写volatile变量state
    return free;
}
```
使用非公平锁时，加锁方法lock()调用轨迹如下
1）ReentrantLock:lock()
2）NonfairSync:lock()
3）AbstractQueuedSynchronizer:compareAndSetState(int expect,int update)
在第3步真正开始加锁，下面是该方法的源代码
```
protected final boolean compareAndSetState(int expect, int update) {
  return unsafe.compareAndSwapInt(this, stateOffset, expect, update);
}
```
JDK文档对compareAndSet()方法的说明如下：如果当前状态值等于预期值，则以原子方式将同步状态设置为给定的更新值。此操作具有volatile读和写的内存语义。

现在对公平锁和非公平锁的内存语义做个总结
* 公平锁和非公平锁释放时，最后都要写一个volatile变量state
* 公平锁获取时，首先会去读volatile变量
* 非公平锁获取时，首先会用CAS更新volatile变量，这个操作同时具有volatile读和volatile写的内存语义
**CAS实现原子操作的三大问题**
1. ABA问题
  CAS需要在操作值的时候，检查值有没有发生变化，如果没有发生变化则更新，但是如果一个值原来是A，变成了B又变成了A，那么使用CAS进行检查时会发现它的值没有发
  生变化，但是实际上却变化了。ABA问题的结局思路就是使用版本号。JDK的Atomic包中AtomicStampedReference类可解决ABA问题。

2. 循环时间长开销大
  自旋CAS如果长时间不成功，会给CPU带来非常大的开销

3. 只能保证一个共享变量的原子操作
  当对一个共享变量执行操作时，我们可以使用循环CAS的方式来保证原子操作，但是对多个共享变量操作时，循环CAS就无法保证操作的原子性

### concurrent包的实现
由于Java的CAS同时具有volatile读和volatile写的内存语义，因此Java线程之间的通信现
在有了下面4种方式。
1）A线程写volatile变量，随后B线程读这个volatile变量。
2）A线程写volatile变量，随后B线程用CAS更新这个volatile变量。
3）A线程用CAS更新一个volatile变量，随后B线程用CAS更新这个volatile变量。
4）A线程用CAS更新一个volatile变量，随后B线程读这个volatile变量。

Java的CAS会使用现代处理器上提供的高效机器级别的原子指令，这些原子指令以原子方式对内存执行读-改-写操作，这是在多处理器中实现同步的关键（从本质上来说，
能够支持原子性读-改-写指令的计算机，是顺序计算图灵机的异步等价机器，因此任何现代的多处理器都会去支持某种能对内存执行原子性读-改-写操作的原子指令）。
同时，volatile变量的读/写和CAS可以实现线程之间的通信。把这些特性整合在一起，就形成了整个concurrent包得以实现的基石。如果我们仔细分析concurrent包的
源代码实现，会发现一个通用化的实现模式。

首先，声明共享变量为volatile。

然后，使用CAS的原子条件更新来实现线程之间的同步。

同时，配合以volatile的读/写和CAS所具有的volatile读和写的内存语义来实现线程之间的通信。

AQS，非阻塞数据结构和原子变量类（java.util.concurrent.atomic包中的类），这些concurrent包中的基础类都是使用这种模式来实现的，而concurrent包中的高
层类又是依赖于这些基础类来实现的。
