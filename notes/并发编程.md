## 一、Java并发机制的底层实现原理
### volatile的应用
  volatile是轻量级的synchronized，它在多处理器开发中保证了共享变量的可见性，即当一个线程修改一个共享变量时，另外一个线程能读到这个修改的值。如果
  volatile变量修饰符使用恰当的话，它比synchronized的使用和执行成本更低，因为它不会引起线程上下文的切换和调度
  
  当写一个volatile变量时，JMM会把该线程对应的本地内存中的共享变量值刷新到主内存。当读一个volatile变量时，，JMM会把该线程对应的本地内存置为无效。线程接
  下来将从主内存中读取共享变量。
### synchronized的应用
  Java中的每一个对象都可作为锁：
  * 对于普通同步方法，锁是当前实例对象
  * 对于静态同步方法，锁是当前类的Class对象
  * 对于同步方法块，锁是synchronized括号里配置的对象
  
  JVM中使用monitorenter和monitorexit指令来实现的。当线程释放锁时，JMM会把该线程对应的本地内存中的共享变量刷新到主内存中。当线程获取锁时，JMM会把该线
  程对应的本地内存置为无效。从而使得被监视器保护的临界区代码必须从主内存中读取共享变量。
#### ReentrantLock源码
ReentrantLock的实现依赖于Java同步器框架AbstractQueuedSynchronizer。AQS使用一个整型的volatile变量（命名为state）来维护同步状态。
* 公平锁
使用公平锁时，加锁方法lock()调用轨迹如下
1）ReentrantLock:lock()
2）FairSync:lock()
3）AbstractQueuedSynchronizer:acquire(int arg)
4）ReentrantLock:tryAcquire(int acquires)
在第4步真正开始加锁，下面是该方法的源代码
```
protected final boolean tryAcquire(int acquires) {
    final Thread current = Thread.currentThread();
    int c = getState();// 获取锁的开始，首先读volatile变量state
    if (c == 0) {
        if (!hasQueuedPredecessors() &&
            compareAndSetState(0, acquires)) {
            setExclusiveOwnerThread(current);
            return true;
        }
    }
    else if (current == getExclusiveOwnerThread()) {
        int nextc = c + acquires;
        if (nextc < 0)
            throw new Error("Maximum lock count exceeded");
        setState(nextc);
        return true;
    }
    return false;
}
```
在使用公平锁时，解锁方法unlock()调用轨迹如下
1）ReentrantLock:unlock()
2）AbstractQueuedSynchronizer:release(int arg)
3）Sync:tryRelease(int releases)
在第3步真正开始释放锁，下面是该方法的源代码
```
protected final boolean tryRelease(int releases) {
    int c = getState() - releases;
    if (Thread.currentThread() != getExclusiveOwnerThread())
        throw new IllegalMonitorStateException();
    boolean free = false;
    if (c == 0) {
        free = true;
        setExclusiveOwnerThread(null);
    }
    setState(c);// 释放锁的最后，写volatile变量state
    return free;
}
```
使用非公平锁时，加锁方法lock()调用轨迹如下
1）ReentrantLock:lock()
2）NonfairSync:lock()
3）AbstractQueuedSynchronizer:compareAndSetState(int expect,int update)
在第3步真正开始加锁，下面是该方法的源代码
```
protected final boolean compareAndSetState(int expect, int update) {
  return unsafe.compareAndSwapInt(this, stateOffset, expect, update);
}
```
JDK文档对compareAndSet()方法的说明如下：如果当前状态值等于预期值，则以原子方式将同步状态设置为给定的更新值。此操作具有volatile读和写的内存语义。

现在对公平锁和非公平锁的内存语义做个总结
* 公平锁和非公平锁释放时，最后都要写一个volatile变量state
* 公平锁获取时，首先会去读volatile变量
* 非公平锁获取时，首先会用CAS更新volatile变量，这个操作同时具有volatile读和volatile写的内存语义

**CAS实现原子操作的三大问题**

1. ABA问题
  CAS需要在操作值的时候，检查值有没有发生变化，如果没有发生变化则更新，但是如果一个值原来是A，变成了B又变成了A，那么使用CAS进行检查时会发现它的值没有发
  生变化，但是实际上却变化了。ABA问题的结局思路就是使用版本号。JDK的Atomic包中AtomicStampedReference类可解决ABA问题。

2. 循环时间长开销大
  自旋CAS如果长时间不成功，会给CPU带来非常大的开销

3. 只能保证一个共享变量的原子操作
  当对一个共享变量执行操作时，我们可以使用循环CAS的方式来保证原子操作，但是对多个共享变量操作时，循环CAS就无法保证操作的原子性

### concurrent包的实现
由于Java的CAS同时具有volatile读和volatile写的内存语义，因此Java线程之间的通信现在有了下面4种方式。

1）A线程写volatile变量，随后B线程读这个volatile变量。

2）A线程写volatile变量，随后B线程用CAS更新这个volatile变量。

3）A线程用CAS更新一个volatile变量，随后B线程用CAS更新这个volatile变量。

4）A线程用CAS更新一个volatile变量，随后B线程读这个volatile变量。

Java的CAS会使用现代处理器上提供的高效机器级别的原子指令，这些原子指令以原子方式对内存执行读-改-写操作，这是在多处理器中实现同步的关键（从本质上来说，
能够支持原子性读-改-写指令的计算机，是顺序计算图灵机的异步等价机器，因此任何现代的多处理器都会去支持某种能对内存执行原子性读-改-写操作的原子指令）。
同时，volatile变量的读/写和CAS可以实现线程之间的通信。把这些特性整合在一起，就形成了整个concurrent包得以实现的基石。如果我们仔细分析concurrent包的
源代码实现，会发现一个通用化的实现模式。

首先，声明共享变量为volatile。

然后，使用CAS的原子条件更新来实现线程之间的同步。

同时，配合以volatile的读/写和CAS所具有的volatile读和写的内存语义来实现线程之间的通信。

AQS，非阻塞数据结构和原子变量类（java.util.concurrent.atomic包中的类），这些concurrent包中的基础类都是使用这种模式来实现的，而concurrent包中的高
层类又是依赖于这些基础类来实现的。

### final域的重排序规则
对于final域，编译器和处理器要遵守两个重排序规则。

1）在构造函数内对一个final域的写入，与随后把这个被构造对象的引用赋值给一个引用变量，这两个操作之间不能重排序。

2）初次读一个包含final域的对象的引用，与随后初次读这个final域，这两个操作之间不能重排序。

如果final域是引用类型，写final域的重排序规则对编译器和处理器增加了如下约束：在构造函数内对一个final引用的对象的成员域的写入，与随后在构造函数外把这
个被构造对象的引用赋值给一个引用变量，这两个操作之间不能重排序。

**在构造函数返回前，被构造对象的引用不能为其他线程所见**

### happens-before的定义
JSR-133使用happens-before的概念来指定两个操作之间的执行顺序。由于这两个操作可以在一个线程之内，也可以是在不同线程之间。因此，JMM可以通过happens-
before关系向程序员提供跨线程的内存可见性保证（如果A线程的写操作a与B线程的读操作b之间存在happens-before关系，尽管a操作和b操作在不同的线程中执行，但
JMM向程序员保证a操作将对b操作可见）

1）如果一个操作happens-before另一个操作，那么第一个操作的执行结果将对第二个操作可见，而且第一个操作的执行顺序排在第二个操作之前

2）两个操作之间存在happens-before关系，并不意味着Java平台的具体实现必须要按照happens-before关系指定的顺序来执行。如果重排序之后的执行结果，与按
happens-before关系来执行的结果一致，那么这种重排序并不非法（也就是说，JMM允许这种重排序）

#### happens-before规则
《JSR-133:Java Memory Model and Thread Specification》定义了如下happens-before规则：

1）程序顺序规则：一个线程中的每个操作，happens-before于该线程中的任意后续操作

2）监视器锁规则：对一个锁的解锁，happens-before于随后对这个锁的加锁

3）volatile变量规则：对一个volatile域的写，happens-before于任意后续对这个volatile域的读

4）传递性：如果A happens-before B，且B happens-before C，那么A happens-before C

5）start()规则：如果线程A执行操作ThreadB.start()（启动线程B），那么A线程的ThreadB.start()操作happens-before于线程B中的任意操作

6）join()规则：如果线程A执行操作ThreadB.join()并成功返回，那么线程B中的任意操作happens-before于线程A从ThreadB.join()操作成功返回

## 二、线程
### 线程的状态
Java线程在运行的生命周期中可能处于下列6个状态中的一种（在给定一个时刻，一个线程只能处于一种状态）：

1. New：初试状态，线程被构建，但是没有调用start()方法

2. Runnable：运行状态，Java线程将操作系统中的就绪和运行状态统称为“运行中”

3. Blocked：阻塞状态，表示线程阻塞于锁

4. Waiting：等待状态，表示线程进入等待状态，进入该状态表示当前线程需要等待其他线程做出一些特定动作（通知或中断）

5. Time_Wating：超时等待状态，线程可以在指定的时间自行返回

6. Terminated：终止状态，表示当前线程已经执行完毕

线程在自身的生命周期中，并不是固定处于某个状态，而是随着代码的执行在不同的状态之间进行切换，Java线程状态变迁如图所示

![image](https://user-images.githubusercontent.com/25001763/71319408-ff1f5200-24d8-11ea-9685-dab364685370.png)

阻塞状态是线程阻塞在进入synchronized关键字修饰的方法或代码块（获取锁）时的状态，但是阻塞在java.concurrent包中Lock接口的线程状态却是等待状态，因为
java.concurrent包中Lock接口对于阻塞的实现均使用了LockSupport类中的相关方法。

### 守护（Daemon）线程
Daemon线程是一种支持型线程，因为它主要被用作程序中后台调度以及支持性工作。这意味着，当一个Java虚拟机中不存在非Daemon线程的时候，Java虚拟机将会退出。
可以通过调用Thread.setDaemon(true)将线程设置为Daemon线程

**Daemon线程被用作完成支持性工作，但是在Java虚拟机退出时Daemon线程中的finally块并不一定会执行**

### 启动和终止线程
#### 构造线程
在运行线程之前首先要构造一个线程对象，线程对象在构造的时候需要提供线程所需要的属性，如线程所属的线程组、线程优先级、是否是Daemon线程等信息。一个新
构造的线程对象是由其parent线程来进行空间分配的，而child线程继承了parent是否为Daemon、优先级和加载资源的contextClassLoader以及可继承的
ThreadLocal，同时还会分配一个唯一的ID来标识这个child线程。至此，一个能够运行的线程对象就初始化好了，在堆内存中等待着运行。

#### 启动线程
线程对象在初始化完成之后，调用start()方法就可以启动这个线程。线程start()方法的含义是：当前线程（即parent线程）同步告知Java虚拟机，只要线程规划器空
闲，应立即启动调用start()方法的线程

#### 线程中断
中断可以理解为线程的一个标识位属性，它表示一个运行中的线程是否被其他线程进行了中断操作。中断好比其他线程对该线程打了个招呼，其他线程通过调用该线程的
interrupt()方法对其进行中断操作。

线程通过检查自身是否被中断来进行响应，线程通过方法isInterrupted()来进行判断是否被中断，也可以调用静态方法Thread.interrupted()对当前线程的中断标识
位进行复位。如果该线程已经处于终结状态，即使该线程被中断过，在调用该线程对象的isInterrupted()时依旧会返回false。

#### 线程间通信
* 等待/通知机制

等待/通知机制，是指一个线程A调用了对象O的wait()方法进入等待状态，而另一个线程B调用了对象O的notify()或者notifyAll()方法，线程A收到通知后从对象O的
wait()方法返回，进而执行后续操作。上述两个线程通过对象O来完成交互，而对象上的wait()和notify/notifyAll()的关系就如同开关信号一样，用来完成等待方和通
知方之间的交互工作

调用wait()、notify()以及notifyAll()时需要注意的细节，如下：

1）使用wait()、notify()和notifyAll()时需要先对调用对象加锁

2）调用wait()方法后，线程状态由RUNNING变为WAITING，并将当前线程放置到对象的等待队列

3）notify()或notifyAll()方法调用后，等待线程依旧不会从wait()返回，需要调用notify()或notifAll()的线程释放锁之后，等待线程才有机会从wait()返回

4）notify()方法将等待队列中的一个等待线程从等待队列中移到同步队列中，而notifyAll()方法则是将等待队列中所有的线程全部移到同步队列，被移动的线程状态由
WAITING变为BLOCKED

5）从wait()方法返回的前提是获得了调用对象的锁

* 管道输入/输出流

管道输入/输出流和普通的文件输入/输出流或者网络输入/输出流不同之处在于，它主要用于线程之间的数据传输，而传输的媒介为内存

管道输入/输出流主要包括了如下4种具体实现：PipedOutputStream、PipedInputStream、PipedReader和PipedWriter，前两种面向字节，而后两种面向字符

* Thread.join()的使用

如果一个线程A执行了thread.join()语句，其含义是：当前线程A等待thread线程终止之后才从thread.join()返回。这里涉及了等待/通知机制（等待前驱线程结束，接收前驱线程结束通知）
