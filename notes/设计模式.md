* [一、UML类图](#一UML类图)
    * [类在类图中的表示方法](#类在类图中的表示方法)
    * [类与类之间关系的表示方式](#类与类之间关系的表示方式)
* [二、设计原则](#二设计原则)
* [三、策略模式](#策略模式)

## 一、UML类图
### 类在类图中的表示方法
在UML类图中，类由一个矩形来表示，矩形中分为三部分，第一部分写类名，第二部分填写类中的属性，第三部分填写类中包含的方法。
![image](https://user-images.githubusercontent.com/25001763/69395239-4b7c4400-0d19-11ea-8bfa-f8ace711ba95.png)

* +：表示public
* -：表示private
* #：表示protected
* _下划线：表示static
* 斜体表示抽象

### 类与类之间关系的表示方式
#### 泛化关系（继承关系）
![image](https://user-images.githubusercontent.com/25001763/69396482-5507ab00-0d1d-11ea-8385-e65e6e1f9f98.png)

用于描述父类与子类之间的关系，**用带空心三角形的实线来表示这种关系，由子类指向父类**
#### 接口实现关系
![image](https://user-images.githubusercontent.com/25001763/69396495-5f29a980-0d1d-11ea-86c9-6cc40e65f51a.png)

用于描述某个类实现某个接口，**用带空心三角形的虚线类表示**
#### 依赖关系
![image](https://user-images.githubusercontent.com/25001763/69396507-6bae0200-0d1d-11ea-86f2-e275559efe77.png)

描述一种**使用关系**，特定事物的改变有可能会影响到使用该事物的其他事物。大多数情况下，依赖关系体现在某个类的方法使用另一个类的对象作为参数。**用一条
带有箭头的虚线表示**
#### 关联关系
关联关系又可进一步分为单向关联和双向关联
   ##### 单向关联
![image](https://user-images.githubusercontent.com/25001763/69396530-7cf70e80-0d1d-11ea-9d2f-4ef8290e8bc9.png)

   描述一个类的某个成员变量是另一个类的实例。**用一个带有箭头的实线来表示**
   ##### 双向关联
    即两个类各种持有对方类型的成员变量，**用不带箭头的实线表示**
#### 聚合关系
![image](https://user-images.githubusercontent.com/25001763/69396641-e840e080-0d1d-11ea-9483-091c1cab9ce9.png)

聚合关系强调的是“整体”包含“部分”，但是“部分”可以脱离“整体”而独立存在。**用带空心菱形和箭头的实线表示**
#### 组合关系
![image](https://user-images.githubusercontent.com/25001763/69396626-d65f3d80-0d1d-11ea-934e-d05056b60c34.png)

组合关系和聚合关系之间最大的不同之处在于：“部分”不能脱离“整体”而独立存在，**用带实心菱形和箭头的实线表示**

## 二、设计原则
### 设计模式的七大原则（设计模式为什么这样设计的依据，也是编程时需要遵循的原则）
1. 单一职责原则
   一个类只负责一个职责  
2. 接口隔离原则
   客户端不应该依赖它不需要的接口，即一个类对另一个类的依赖应该建立在最小的接口上。如果一个接口中的方法很多，某个类依赖这个接口时只会使用一部分方法，
   那么就应该把接口拆分成多个接口。
3. 依赖倒转原则
   1) 高层模块不应该依赖低层模块，二者都应该依赖其抽象
   2) 抽象不应该依赖细节，细节应该依赖抽象
   3) 依赖倒转的中心思想是面向接口编程
   4) 使用接口或抽象类的目的是制定**规范**，而不设计任何操作，把**展现细节的操作交个它们的实现类**去完成
   编程时，在遇到依赖的时候，应该通过接口来完成依赖的传递
   注意事项和细节：
   1) 低层模块（被依赖的模块）尽量都要有抽象类或接口，或者两者都有，这样程序稳定性更好
   2) 变量的声明类型尽量是抽象类或接口
   3) 继承时应该遵循里氏替换原则
4. 里氏替换原则
   在使用继承时，在子类中尽量不要重写父类方法
   继承实际上增加了两个类之间的耦合性，可以通过**聚合、组合、依赖**等方法来替换继承来解决问题
5. 开闭原则
   1) 一个软件实体，如类、模块或函数，应该对扩展开放（提供方），对修改关闭（使用方）。用抽象构建框架，用实现扩展细节
   2) 当软件需要变化时，尽量通过**扩展**软件实体的行为来实现变化，而不是通过**修改**已有的代码来实现变化
   3) 编程中遵循其他原则，以及使用设计模式的目的就是遵循开闭原则
6. 迪米特法则
   1) 一个对象应该对其他对象保持最少的了解
   2) 类与类关系越密切，耦合度越大
   3) 迪米特法则又叫**最少知道原则**，即一个类对自己依赖的类知道的越少越好，也就是说，对于被依赖的类不管多么复杂，都尽量将逻辑封装在类的内部，除了提
   供的public方法，不对外泄露任何信息。
   4) 只与直接的朋友进行通信
      **直接的朋友**：每个对象都会与其他对象有耦合关系，只要两个对象之间有耦合关系，那么就说这两个对象是朋友关系。**耦合**的方式很多：依赖、关联、组
      合、聚合等。其中，我们称出现在成员变量、方法参数、方法返回值中的对象为直接的朋友。而出现在局部变量的对象就不是直接朋友。也就是说，**陌生的类**
      **好不要以局部变量的形式出现在类的内部**。
7. 合成复用原则
   尽量使用合成/聚合的方式，而不是使用继承

### Head First 设计模式中提出的设计原则
* 找出应用中可能需要变化之处，把它们独立出来，不要和那些不需要变化的代码混在一起
* 针对接口编程，而不是针对实现编程
* 多用组合，少用继承

## 三、策略模式
### 策略模式

**策略模式**定义了算法族，分别封装起来，让它们之间可以互相替换，此模式让算法的变化独立于使用算法的客户。

在设计类时，我们需要将类中变化的行为独立出来，设计描述该行为的接口，让各种不同的具体行为来实现接口。而在初始类中用“组合”的方式来使用这些具体的行为。
![image](https://user-images.githubusercontent.com/25001763/69508588-3a2d7480-0f71-11ea-89f0-7dcc1fc16f67.png)

在上述的类图中，Duck类是基类，我们将其中的fly（飞行）和quack（叫声）属性独立出来，设计了FlyBehavior和QuackBehavior接口，让具体的飞行类和叫声类来实
现这个接口，描述各自不同的行为。然后在Duck类中添加FlyBehavior和QuackBehavior的对象来使用和两个行为。
