学习设计模式首先看的《Head First设计模式》这本书，然后看了讲解设计模式的视频。本篇内容大部分来自《Head First 设计模式》

* [一、UML类图](#一UML类图)
    * [类在类图中的表示方法](#类在类图中的表示方法)
    * [类与类之间关系的表示方式](#类与类之间关系的表示方式)
* [二、设计原则](#二设计原则)
* [三、策略模式](#三策略模式)
* [四、观察者模式](#四观察者模式)
* [五、装饰者模式](#五装饰者模式)
* [六、工厂模式](#六工厂模式)

## 一、UML类图
### 类在类图中的表示方法
在UML类图中，类由一个矩形来表示，矩形中分为三部分，第一部分写类名，第二部分填写类中的属性，第三部分填写类中包含的方法。
![image](https://user-images.githubusercontent.com/25001763/69395239-4b7c4400-0d19-11ea-8bfa-f8ace711ba95.png)

* +：表示public
* -：表示private
* #：表示protected
* _下划线：表示static
* 斜体表示抽象

### 类与类之间关系的表示方式
#### 泛化关系（继承关系）
![image](https://user-images.githubusercontent.com/25001763/69396482-5507ab00-0d1d-11ea-8385-e65e6e1f9f98.png)

用于描述父类与子类之间的关系，**用带空心三角形的实线来表示这种关系，由子类指向父类**
#### 接口实现关系
![image](https://user-images.githubusercontent.com/25001763/69396495-5f29a980-0d1d-11ea-86c9-6cc40e65f51a.png)

用于描述某个类实现某个接口，**用带空心三角形的虚线类表示**
#### 依赖关系
![image](https://user-images.githubusercontent.com/25001763/69396507-6bae0200-0d1d-11ea-86f2-e275559efe77.png)

描述一种**使用关系**，特定事物的改变有可能会影响到使用该事物的其他事物。大多数情况下，依赖关系体现在某个类的方法使用另一个类的对象作为参数。**用一条
带有箭头的虚线表示**
#### 关联关系
关联关系又可进一步分为单向关联和双向关联
   ##### 单向关联
![image](https://user-images.githubusercontent.com/25001763/69396530-7cf70e80-0d1d-11ea-9d2f-4ef8290e8bc9.png)

   描述一个类的某个成员变量是另一个类的实例。**用一个带有箭头的实线来表示**
   ##### 双向关联
    即两个类各种持有对方类型的成员变量，**用不带箭头的实线表示**
#### 聚合关系
![image](https://user-images.githubusercontent.com/25001763/69396641-e840e080-0d1d-11ea-9483-091c1cab9ce9.png)

聚合关系强调的是“整体”包含“部分”，但是“部分”可以脱离“整体”而独立存在。**用带空心菱形和箭头的实线表示**
#### 组合关系
![image](https://user-images.githubusercontent.com/25001763/69396626-d65f3d80-0d1d-11ea-934e-d05056b60c34.png)

组合关系和聚合关系之间最大的不同之处在于：“部分”不能脱离“整体”而独立存在，**用带实心菱形和箭头的实线表示**

## 二、设计原则
### 设计模式的七大原则（设计模式为什么这样设计的依据，也是编程时需要遵循的原则）
1. 单一职责原则
   一个类只负责一个职责  
2. 接口隔离原则
   客户端不应该依赖它不需要的接口，即一个类对另一个类的依赖应该建立在最小的接口上。如果一个接口中的方法很多，某个类依赖这个接口时只会使用一部分方法，
   那么就应该把接口拆分成多个接口。
3. 依赖倒转原则
   1) 高层模块不应该依赖低层模块，二者都应该依赖其抽象
   2) 抽象不应该依赖细节，细节应该依赖抽象
   3) 依赖倒转的中心思想是面向接口编程
   4) 使用接口或抽象类的目的是制定**规范**，而不设计任何操作，把**展现细节的操作交个它们的实现类**去完成
   编程时，在遇到依赖的时候，应该通过接口来完成依赖的传递
   注意事项和细节：
   1) 低层模块（被依赖的模块）尽量都要有抽象类或接口，或者两者都有，这样程序稳定性更好
   2) 变量的声明类型尽量是抽象类或接口
   3) 继承时应该遵循里氏替换原则
4. 里氏替换原则
   在使用继承时，在子类中尽量不要重写父类方法
   继承实际上增加了两个类之间的耦合性，可以通过**聚合、组合、依赖**等方法来替换继承来解决问题
5. 开闭原则
   1) 一个软件实体，如类、模块或函数，应该对扩展开放（提供方），对修改关闭（使用方）。用抽象构建框架，用实现扩展细节
   2) 当软件需要变化时，尽量通过**扩展**软件实体的行为来实现变化，而不是通过**修改**已有的代码来实现变化
   3) 编程中遵循其他原则，以及使用设计模式的目的就是遵循开闭原则
6. 迪米特法则
   1) 一个对象应该对其他对象保持最少的了解
   2) 类与类关系越密切，耦合度越大
   3) 迪米特法则又叫**最少知道原则**，即一个类对自己依赖的类知道的越少越好，也就是说，对于被依赖的类不管多么复杂，都尽量将逻辑封装在类的内部，除了提
   供的public方法，不对外泄露任何信息。
   4) 只与直接的朋友进行通信
      **直接的朋友**：每个对象都会与其他对象有耦合关系，只要两个对象之间有耦合关系，那么就说这两个对象是朋友关系。**耦合**的方式很多：依赖、关联、组
      合、聚合等。其中，我们称出现在成员变量、方法参数、方法返回值中的对象为直接的朋友。而出现在局部变量的对象就不是直接朋友。也就是说，**陌生的类**
      **好不要以局部变量的形式出现在类的内部**。
7. 合成复用原则
   尽量使用合成/聚合的方式，而不是使用继承

### Head First 设计模式中提出的设计原则
* 找出应用中可能需要变化之处，把它们独立出来，不要和那些不需要变化的代码混在一起
* 针对接口编程，而不是针对实现编程
* 多用组合，少用继承
* 为了交互对象之间的松耦合设计而努力
* 开闭原则：类应该对扩展开放，对修改关闭。也就是说，让类容易扩展，在不修改现有代码的情况下，就可搭配新的行为。这样的设计具有弹性，可以应对改变，可以接
            受新的功能来应对改变的需求。**不必使代码的每个部分都采用开闭原则**，这会增加代码的复杂度，只需在最有可能改变的地方运用即可。

## 三、策略模式

**策略模式**定义了算法族，分别封装起来，让它们之间可以互相替换，此模式让算法的变化独立于使用算法的客户。

在设计类时，我们需要将类中变化的行为独立出来，设计描述该行为的接口，让各种不同的具体行为来实现接口。而在初始类中用“组合”的方式来使用这些具体的行为。

![image](https://user-images.githubusercontent.com/25001763/69508588-3a2d7480-0f71-11ea-89f0-7dcc1fc16f67.png)

在上述的类图中，Duck类是基类，我们将其中的fly（飞行）和quack（叫声）属性独立出来，设计了FlyBehavior和QuackBehavior接口，让具体的飞行类和叫声类来实
现这个接口，描述各自不同的行为。然后在Duck类中添加FlyBehavior和QuackBehavior的对象来使用和两个行为。

## 四、观察者模式

### 定义
观察者模式定义了对象之间的**一对多依赖**，这样一来，当一个对象改变状态时，它的**所有依赖者**都会收到通知并自动更新

![image](https://user-images.githubusercontent.com/25001763/69613497-9de89800-106c-11ea-869e-fcd04e9239f3.png)

观察者模式提供了一种对象设计，让主题和观察者之间松耦合。当两个对象之间松耦合，它们依然可以交互，但是不太清楚彼此的细节。**在Swing中就用到了观察者模**

一个使用观察者模式的例子：
   有一个WeatherData对象来观测气象数据，有多个公告板需要使用WeatherData对象观测的数据来展示这些数据，而且数据更新时公告板能够立即得到通知并更新自己
   展示的数据。[代码示例](https://github.com/wyjie0/Java_learning-WYJ/issues/16)

我们也可以使用java.util包中的Observable类和Observer接口来实现观察者模式，被观察者（主题）继承Observable类，观察者实现Observer接口。但是，因为
Observable是一个类，必须设计一个类继承它。如果某类相同时具有Observable类和另一个超类的行为，那就不可行。

* 观察者模式遵循的设计原则：
   * 找出程序中会变化的方面，然后将其和固定不变的方面分离
      
      在观察者模式中，会改变的是主题的状态，以及观察者的数目和类型。用这个模式，可以改变依赖于主题状态的对象，却不必改变主题。
   * 针对接口编程，不针对实现编程
      
      主题与观察者都使用接口，观察者利用主题的接口向主题注册，而主题利用观察者接口通知观察者。这样可以让两者之间运作正常，又同时具有松耦合的有点。
   * 多用组合，少用继承
      
      观察者模式利用“组合”将许多观察者组合进主题中，对象之间的这种关系不是通过继承产生的，而是在运行时利用组合的方式而产生的。
      
## 五、装饰者模式

### 定义
装饰者模式动态地将责任附加到对象上，若要扩展功能，装饰者提供了比继承更有弹性的替代方案

* 装饰者和被装饰对象有相同的超类型
* 可以用一个或多个装饰者包装一个对象
* 装饰者可以在所委托被装饰者的行为之前或之后，加上自己的行为，以达到特定的目的
* 对象可以在任何时候被装饰，所以可以在运行时动态地、不限量地用各种装饰者来装饰对象
![image](https://user-images.githubusercontent.com/25001763/69771748-d69d8400-11c8-11ea-9bad-1d8368615fb3.png)

图中，ConcreteComponent继承Component抽象类是为了有正确的类型，而不是继承它的行为。行为来自装饰者和基础组件，或与其他装饰者之间的组合关系。且图中的
抽象类Component和Decorator在自己实现的时候都可以改写为接口（interface）。[代码示例](https://github.com/wyjie0/Java_learning-WYJ/issues/17)

## 六、工厂模式

### 工厂方法
工厂方法用来处理对象的创建，并将这样的行为封装在子类中（在子类中来具体实现创建对象的行为）。这样，客户程序中关于超类的代码就和子类对象创建代码解耦了
![image](https://user-images.githubusercontent.com/25001763/69839242-aff75000-1291-11ea-8ea4-ed1e2249c231.png)
![image](https://user-images.githubusercontent.com/25001763/69839282-d4ebc300-1291-11ea-803f-63b242611190.png)
[代码示例](https://github.com/wyjie0/Java_learning-WYJ/issues/18)

### 认识工厂方法模式
偶有工厂模式都用来封装对象的创建。工厂方法模式通过让**子类决定**该创建的对象是什么，来达到将对象创建的过程封装的目的。
![image](https://user-images.githubusercontent.com/25001763/69841043-b3420a00-1298-11ea-96e5-e4f5cb0c5881.png)
![image](https://user-images.githubusercontent.com/25001763/69841054-c1902600-1298-11ea-9ed9-4635fe2005b4.png)

### 定义工厂方法模式
工厂方法模式定义了一个创建对象的接口，但由子类决定要实例化的类是哪一个。**工厂方法让类把实例化推迟到子类**。
