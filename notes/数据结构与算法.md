# Algorithm
算法学习（java）
根据自己学习《算法导论》的顺序，每一部分附加一些LeetCode上面的题目（也会从大牛那儿借鉴内容），记录自己算法的学习过程。
* [一、算法基础](#一算法基础)
    * [分治策略](#分治策略)
      * [最大子数组问题](#最大子数组问题)
      * [归并排序算法](#归并排序算法)
      * [LeetCode 241 Different Ways to Add Parentheses](#LeetCode 241 Different Ways to Add Parentheses)
      * [求两个有序数组中的中位数 LeetCode 4](#求两个有序数组中的中位数 LeetCode 4)
* [二、排序算法](#二排序算法)
   * [堆排序](#堆排序)
   * [快速排序](#快速排序)
   * [归并排序](#归并排序)
* [三、数据结构](#三数据结构)
   * [二叉搜索树](#二叉搜索树)
   * [红黑树](#红黑树)
* [四、高级设计与分析技术](#四高级设计与分析技术)
   * [贪心算法](#贪心算法)
   * [动态规划](#动态规划)

## 一、算法基础
### 分治策略
在分治策略中，要递归的解决一个问题，在每层递归中应用如下三个步骤：
1. 分解：将问题划分为一些子问题，子问题的形式与原问题一样，只是规模更小（从中分解还是从头开始分解）
2. 解决：递归地求解出子问题，如果子问题的规模足够小，则停止递归，直接求解（如何定义最小子问题）
3. 合并：将子问题的解组合成原问题的解（如何合并）
求解问题需要找出基线条件和递归条件。
一些做到的算法题：
#### [最大子数组问题](https://github.com/wyjie0/Algorithm/issues/2)
#### [归并排序算法](https://github.com/wyjie0/Algorithm/issues/3)
#### [LeetCode 241 Different Ways to Add Parentheses](https://github.com/wyjie0/Algorithm/issues/4)
#### [求两个有序数组中的中位数 LeetCode 4](https://github.com/wyjie0/Algorithm/issues/5)


## 二、排序算法
### 堆排序
#### 堆
二叉堆可分为两种形式：最大堆（根节点的值大于其子节点的值）和最小堆（根节点的值小于其子节点的值），可以完全二叉树或一维数组的方式来表示。最小堆通常用于
构造优先队列
##### 维护堆的性质（时间复杂度O(logn)）
在堆中添加或者删除数据的时候，我们需要维持堆的基本性质maxHeapify是维护最大堆性质的重要过程，它输入一个数组A和一个下标i。调用该方法的时候，我们假定left(i)和right(i)的二叉树都是最大堆，但这时A[i]有可能小于其孩子，该方法通过让A[i]的值在最大堆中“逐级下降”，从而使得以下标i为根节点的子树重新遵循最大堆的性质
```
//维持堆的性质(在数组中，下标需要减1。在数组中以下标来代表树中的下标时，需要从1开始)
//i代表该元素在树中的位置（根节点的索引为1）
//length代表有效元素的个数
public static void maxHeapify(int[] A, int i, int length) {
    int left = left(i);
    int right = right(i);
    int largest = i;
    if (left <= length && A[left - 1] > A[i - 1]) largest = left;
    if (right <= length && A[right - 1] > A[largest - 1]) largest = right;
    if (largest != i) {
        A[i - 1] = A[i - 1] + A[largest - 1];
        A[largest - 1] = A[i - 1] - A[largest - 1];
        A[i - 1] = A[i - 1] - A[largest - 1];
        maxHeapify(A, largest, length);
    }
}
```
![image](https://user-images.githubusercontent.com/25001763/69324745-fa6e4080-0c83-11ea-84cc-4f339de1a853.png)

##### 构建堆（时间复杂度O(n)）
可以使用自底向上的方法利用maxHeapify方法把一个大小为n=A.length的数组A转换为最大堆。因为子数组A[n/2..n-1]中的元素都是树的叶子结点。每个叶子结点都可
以看成只包含一个元素的堆。方法buildMaxHeap对树中的其他节点都调用一次maxHeapify方法。也就是自底向上对每一个非叶子结点都调整一下其结构，使其满足最大
堆的性质
```
//构建堆
public static void buildMaxHeap(int[] A) {
    for (int i = A.length / 2; i >= 1; i--) maxHeapify(A, i, A.length);
}
```
##### 堆排序
初始时候，堆排序算法利用buildMaxHeap将输入数组A建成最大堆。因为数组中的最大元素总在根节点A[1]中，通过把它与A[n]互换，我们可以让元素放到正确的位置。
这时，如果我们从堆中去掉节点n，剩余的节点中，原来根的孩子节点任然是最大堆，但是新的根节点可能会违背最大堆的性质，所以我们要调用maxHeapify(A,1)，重新
构造一个新的最大堆。堆排序算法会不断重复这一过程，直到堆的大小从n-1降到2。
```
//堆排序
public static int[] heapSort(int[] A) {
    List<Integer> ret = new ArrayList<>();
    int validLength = A.length;
    for (int i = A.length; i >= 2; i--) {
        A[0] = A[0] + A[i - 1];
        A[i - 1] = A[0] - A[i - 1];
        A[0] = A[0] - A[i - 1];
        maxHeapify(A, 1, --validLength);
    }
    return A;
}
```
#### 优先队列
```
import java.util.ArrayList;
import java.util.List;

public class MyPriorityQueue {
    private List<Integer> queue;
    private int heapSize;

    public MyPriorityQueue() {
        this.queue = new ArrayList<>();
        heapSize = queue.size();
    }
    private int left(int i) { return 2 * i; }
    private int right(int i) { return 2 * i + 1; }
    private int parent(int i) { return i / 2; }
    private void swap(List<Integer> queue, int i, int j) {
        int temp = queue.get(i - 1);
        queue.set(i - 1, queue.get(j - 1));
        queue.set(j - 1, temp);
    }
    private void maxHeapify(List<Integer> queue, int i) {
        int largest = i;
        int left = left(i);
        int right = right(i);

        if (left < heapSize && queue.get(i - 1) < queue.get(left - 1)) largest = left;
        if (right < heapSize && queue.get(largest - 1) < queue.get(right - 1)) largest = right;
        if (largest != i) {
            swap(queue, largest, i);
            maxHeapify(queue, largest);
        }
    }

    //获取堆中的最大值
    public int heapMaximum() {
        return queue.get(0);
    }

    //获取最大值并删除,时间复杂度为O(logn)，除了maxHeapify的时间复杂度为O(logn)，其他的操作都是常数阶
    public int heapExtractMax() {
        if (queue.size() < 1) {
            System.out.println("队列为空！");
            return Integer.MIN_VALUE;
        }
        int max = queue.get(0);
        swap(queue, 1, heapSize);
        heapSize--;
        maxHeapify(queue, 1);
        return max;
    }

    //将队列中第i个节点的值增加到key，key必须大于原始值
    public void heapIncreaseKey(int i, int key) {
        if (key < queue.get(i - 1)) {
            System.out.println("new key is smaller than current key");
            return;
        }
        queue.set(i - 1, key);
        while (i > 1 && queue.get(parent(i) - 1) < queue.get(i - 1)) {
            swap(queue, i, parent(i));
            i = parent(i);
        }
    }

    //向队列中添加元素
    public void insert(Integer element) {
        heapSize++;
        queue.add(Integer.MIN_VALUE);//将最后一个节点设为最小值
        heapIncreaseKey(heapSize, element);//通过heapIncreaseKey算法提升新增节点的位置
    }

    @Override
    public String toString() {
        return "MyPriorityQueue{" +
                "queue=" + queue +
                ", heapSize=" + heapSize +
                '}';
    }
}

```

### 快速排序
对数组A[p...r]进行快速排序的三步分治过程
* 分解：数组A[p...r]被划分为两个（可能为空）子数组A[p...q-1]和A[q+1...r]，使得A[p...q-1]中的每一个元素都小于等于A[q]，而A[q]也小于等于A[q+1...r]
中的每一个元素。其中，计算下标q也是划分过程的一部分。
* 解决：通过递归调用快速排序，对子数组A[p...q-1]和A[q+1...r]进行排序
* 合并：因为子数组都是原址排序，所以不需要合并操作
```
//快速排序算法
public static void quickSort(int[] A, int p, int r) {
    if (p < r) {
        int q = partion(A, p, r);
        quickSort(A, p, q - 1);
        quickSort(A, q + 1, r);
    }
}
```
为了排序一个数组A的全部元素，起始调用是partition(A, 0, A.length - 1)
##### 数组的划分
算法的关键部分就在于对数组的划分，它实现了对子数组A[p..r]的原址重排
```
public static int partition(int[] A, int p, int r) {
    int pivot = A[r];
    int i = p - 1;
    //0--i的数都为小于pivot的数，i+1--r的数都为大于pivot的数
    for (int j = p; j < r; j++) {
        //i代表比pivot小的数的个数，如果遇到比pivot小的数，i就递增
        if (A[j] <= pivot) {
            i++;
            int temp = A[i];
            A[i] = A[j];
            A[j] = temp;
        }
    }
    int temp = A[i + 1];
    A[i + 1] = A[r];
    A[r] = temp;
    return i + 1;
}
```
在一个样例数组上的partition操作过程如下：

![image](https://user-images.githubusercontent.com/25001763/68922239-12425200-07b6-11ea-8d4d-b846c80f66ce.png)

在子数组A[p..r]上，partition维护了4个区域。A[p..i]区间内的所有值都小于等于x，A[i+1...j-1]区间内的所有值都大于x，A[r]=x。子数组A[j..r-1]中的值可能属于任何一种情况

##### 快速排序的性能
快速排序的运行时间依赖于划分是否平衡，而平衡与否又依赖于用于划分的元素。如果划分是平衡的，那么快速排序算法性能与归并排序一样。如果划分是不平衡的，那么快速排序的性能就接近于插入排序了。

##### 快速排序的随机化版本
与始终采用A[r]作为主元的方法不同，随机抽样是从子数组A[p..r]中随机选择一个元素作为主元。为达到这一目的，首先将A[r]与从A[p..r]中随机选出的一个元素交换。通过对序列p,...,r的随机抽样，我们可以保证主元元素x=A[r]是等概率地从子数组的元素中选取的。
```
/**
     * 快速排序的随机化版本
     */
    public static int randomizedPartition(int[] A, int p, int r) {
        Random random = new Random();
        int i = random.nextInt(r - p + 1) + p;
        int temp = A[r];
        A[r] = A[i];
        A[i] = temp;
        return partition(A, p, r);
    }
    public static void randomizedQuicksort(int[] A, int p, int r) {
        if (p < r) {
            int q = randomizedPartition(A, p, r);
            randomizedQuicksort(A, p, q - 1);
            randomizedQuicksort(A, q + 1, r);
        }
    }
```

### 归并排序算法（分治策略）
* 分解：分解待排序的n个元素的序列成各具n/2个元素的两个子序列
* 解决：使用归并排序递归地排序两个子序列
* 合并：合并两个已排序的子序列以产生已排序的答案 </br>
关键操作时“合并”步骤中两个已排序序列的合并。通过merge(A,p,q,r)来完成合并，其中A是一个数组，p、q和r是数组的下标，满足p <= q < r。假设子数组A[p..q]和A[q+1..r]都已排好序。它合并这两个子数组形成单一的已排好序的子数组代替当前的子数组A[p..r]。
```
public static void mergeSort(int[] A, int p, int r) {
        if (p < r) {
            int q = (p + r) / 2;
            mergeSort(A, p, q);
            mergeSort(A, q + 1, r);
            merge(A, p, q, r);
        }
    }
    public static void merge(int[] A, int p, int q, int r) {
        int[] left = new int[q - p + 1 + 1];
        int[] right = new int[r - q + 1];
        for (int i = 0; i < q - p + 1; i++) {
            left[i] = A[p + i];
        }
        for (int i = 0; i < r - q; i++) {
            right[i] = A[q + i + 1];
        }
        left[left.length - 1] = Integer.MAX_VALUE;
        right[right.length - 1] = Integer.MAX_VALUE;
        int i = 0, j = 0;
        for (int k = p; k <= r; k++) {
            if (left[i] <= right[j]) {
                A[k] = left[i++];
            } else A[k] = right[j++];
        }
    }
```
为避免在每个基本步骤必须检查是否有子数组为空，在每个子数组的末尾都放置了一张**哨兵**牌，它包含一个特殊的值，用于简化代码。当两个子数组都出现哨兵值的时候，说明所有非哨兵牌都已经被放置到输出数组中了。
