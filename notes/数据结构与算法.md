# Algorithm
算法学习（java）
根据自己学习《算法导论》的顺序，每一部分附加一些LeetCode上面的题目（也会从大牛那儿借鉴内容），记录自己算法的学习过程。
* [一、算法基础](#一算法基础)
    * [分治策略](#分治策略)
      * [最大子数组问题](#最大子数组问题)
      * [归并排序算法](#归并排序算法)
      * [LeetCode 241 Different Ways to Add Parentheses](#LeetCode 241 Different Ways to Add Parentheses)
      * [求两个有序数组中的中位数 LeetCode 4](#求两个有序数组中的中位数 LeetCode 4)
* [二、排序算法](#二排序算法)
   * [堆排序](#堆排序)
   * [快速排序](#快速排序)
   * [归并排序](#归并配排序)
* [三、数据结构](#三数据结构)
   * [二叉搜索树](#二叉搜索树)
   * [红黑树](#红黑树)
* [四、高级设计与分析技术](#四高级设计与分析技术)
   * [贪心算法](#贪心算法)
   * [动态规划](#动态规划)

## 一、算法基础
### 分治策略
在分治策略中，要递归的解决一个问题，在每层递归中应用如下三个步骤：
1. 分解：将问题划分为一些子问题，子问题的形式与原问题一样，只是规模更小（从中分解还是从头开始分解）
2. 解决：递归地求解出子问题，如果子问题的规模足够小，则停止递归，直接求解（如何定义最小子问题）
3. 合并：将子问题的解组合成原问题的解（如何合并）
求解问题需要找出基线条件和递归条件。
一些做到的算法题：
#### [最大子数组问题](https://github.com/wyjie0/Algorithm/issues/2)
#### [归并排序算法](https://github.com/wyjie0/Algorithm/issues/3)
#### [LeetCode 241 Different Ways to Add Parentheses](https://github.com/wyjie0/Algorithm/issues/4)
#### [求两个有序数组中的中位数 LeetCode 4](https://github.com/wyjie0/Algorithm/issues/5)


## 二、排序算法
### 堆排序
#### 堆
二叉堆可分为两种形式：最大堆（根节点的值大于其子节点的值）和最小堆（根节点的值小于其子节点的值），可以完全二叉树或一维数组的方式来表示。最小堆通常用于
构造优先队列
##### 维护堆的性质（时间复杂度O(logn)）
在堆中添加或者删除数据的时候，我们需要维持堆的基本性质maxHeapify是维护最大堆性质的重要过程，它输入一个数组A和一个下标i。调用该方法的时候，我们假定left(i)和right(i)的二叉树都是最大堆，但这时A[i]有可能小于其孩子，该方法通过让A[i]的值在最大堆中“逐级下降”，从而使得以下标i为根节点的子树重新遵循最大堆的性质
```
//维持堆的性质(在数组中，下标需要减1。在数组中以下标来代表树中的下标时，需要从1开始)
//i代表该元素在树中的位置（根节点的索引为1）
//length代表有效元素的个数
public static void maxHeapify(int[] A, int i, int length) {
    int left = left(i);
    int right = right(i);
    int largest = i;
    if (left <= length && A[left - 1] > A[i - 1]) largest = left;
    if (right <= length && A[right - 1] > A[largest - 1]) largest = right;
    if (largest != i) {
        A[i - 1] = A[i - 1] + A[largest - 1];
        A[largest - 1] = A[i - 1] - A[largest - 1];
        A[i - 1] = A[i - 1] - A[largest - 1];
        maxHeapify(A, largest, length);
    }
}
```
![image](https://user-images.githubusercontent.com/25001763/69324745-fa6e4080-0c83-11ea-84cc-4f339de1a853.png)

##### 构建堆（时间复杂度O(n)）
可以使用自底向上的方法利用maxHeapify方法把一个大小为n=A.length的数组A转换为最大堆。因为子数组A[n/2..n-1]中的元素都是树的叶子结点。每个叶子结点都可
以看成只包含一个元素的堆。方法buildMaxHeap对树中的其他节点都调用一次maxHeapify方法。也就是自底向上对每一个非叶子结点都调整一下其结构，使其满足最大
堆的性质
```
//构建堆
public static void buildMaxHeap(int[] A) {
    for (int i = A.length / 2; i >= 1; i--) maxHeapify(A, i, A.length);
}
```
##### 堆排序
初始时候，堆排序算法利用buildMaxHeap将输入数组A建成最大堆。因为数组中的最大元素总在根节点A[1]中，通过把它与A[n]互换，我们可以让元素放到正确的位置。
这时，如果我们从堆中去掉节点n，剩余的节点中，原来根的孩子节点任然是最大堆，但是新的根节点可能会违背最大堆的性质，所以我们要调用maxHeapify(A,1)，重新
构造一个新的最大堆。堆排序算法会不断重复这一过程，直到堆的大小从n-1降到2。
```
//堆排序
public static int[] heapSort(int[] A) {
    List<Integer> ret = new ArrayList<>();
    int validLength = A.length;
    for (int i = A.length; i >= 2; i--) {
        A[0] = A[0] + A[i - 1];
        A[i - 1] = A[0] - A[i - 1];
        A[0] = A[0] - A[i - 1];
        maxHeapify(A, 1, --validLength);
    }
    return A;
}
```
#### 优先队列
```
import java.util.ArrayList;
import java.util.List;

public class MyPriorityQueue {
    private List<Integer> queue;
    private int heapSize;

    public MyPriorityQueue() {
        this.queue = new ArrayList<>();
        heapSize = queue.size();
    }
    private int left(int i) { return 2 * i; }
    private int right(int i) { return 2 * i + 1; }
    private int parent(int i) { return i / 2; }
    private void swap(List<Integer> queue, int i, int j) {
        int temp = queue.get(i - 1);
        queue.set(i - 1, queue.get(j - 1));
        queue.set(j - 1, temp);
    }
    private void maxHeapify(List<Integer> queue, int i) {
        int largest = i;
        int left = left(i);
        int right = right(i);

        if (left < heapSize && queue.get(i - 1) < queue.get(left - 1)) largest = left;
        if (right < heapSize && queue.get(largest - 1) < queue.get(right - 1)) largest = right;
        if (largest != i) {
            swap(queue, largest, i);
            maxHeapify(queue, largest);
        }
    }

    //获取堆中的最大值
    public int heapMaximum() {
        return queue.get(0);
    }

    //获取最大值并删除,时间复杂度为O(logn)，除了maxHeapify的时间复杂度为O(logn)，其他的操作都是常数阶
    public int heapExtractMax() {
        if (queue.size() < 1) {
            System.out.println("队列为空！");
            return Integer.MIN_VALUE;
        }
        int max = queue.get(0);
        swap(queue, 1, heapSize);
        heapSize--;
        maxHeapify(queue, 1);
        return max;
    }

    //将队列中第i个节点的值增加到key，key必须大于原始值
    public void heapIncreaseKey(int i, int key) {
        if (key < queue.get(i - 1)) {
            System.out.println("new key is smaller than current key");
            return;
        }
        queue.set(i - 1, key);
        while (i > 1 && queue.get(parent(i) - 1) < queue.get(i - 1)) {
            swap(queue, i, parent(i));
            i = parent(i);
        }
    }

    //向队列中添加元素
    public void insert(Integer element) {
        heapSize++;
        queue.add(Integer.MIN_VALUE);//将最后一个节点设为最小值
        heapIncreaseKey(heapSize, element);//通过heapIncreaseKey算法提升新增节点的位置
    }

    @Override
    public String toString() {
        return "MyPriorityQueue{" +
                "queue=" + queue +
                ", heapSize=" + heapSize +
                '}';
    }
}

```
